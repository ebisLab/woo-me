{"ast":null,"code":"export var getFloatval = function getFloatval(string) {\n  console.log(\"string\", string);\n  var floatValue = string.match(/[+-]?\\d+(\\.\\d+)?/g)[0];\n  return null !== floatValue ? parseFloat(parseFloat(floatValue).toFixed(2)) : '';\n};\nexport var addFirstProduct = function addFirstProduct(product) {\n  console.log('heey from inside the addproduct');\n  var productPrice = getFloatval(product.price); //if no item in the cart, create an n empty array and pushe the item\n\n  var newCart = {\n    products: [],\n    totalProductsCount: 1,\n    totalProductsPrice: productPrice\n  };\n  var newProduct = createNewProduct(product, productPrice, 1); //qty is 1 b/c its the first time we're creating it\n\n  newCart.products.push(newProduct);\n  localStorage.setItem('woo-next-cart', JSON.stringify(newCart));\n  return newCart;\n}; //CREATE A NEW PRODUCT OBJECT\n\nexport var createNewProduct = function createNewProduct(product, productPrice, qty) {\n  return {\n    productId: product.productId,\n    image: product.image,\n    name: product.name,\n    price: productPrice,\n    qty: qty,\n    totalPrice: parseFloat((productPrice * qty).toFixed(2))\n  };\n};\nexport var updateCart = function updateCart(existingCart, product, qtyToBeAdded) {\n  var newQty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var updatedProducts = getUpdatedProducts(existingCart.products, product, qtyToBeAdded, newQty);\n\n  var addPrice = function addPrice(total, item) {\n    total.totalPrice += item.totalPrice;\n    total.qty += item.qty;\n    return total;\n  }; //loop thtrough the update produt array and add the totalPrice of each item to get the totalPrice.\n\n\n  var total = updatedProducts.reduce(addPrice, {\n    totalPrice: 0,\n    qty: 0\n  }); //updated card\n\n  var updatedCart = {\n    products: updatedProducts,\n    totalProductsCount: parseInt(total.qty),\n    totalProductsPrice: parseFloat(total.totalPrice)\n  };\n  localStorage.setItem('woo-next-cart', JSON.stringify(updatedCart));\n  return updatedCart;\n}; //get updated products array\n//updated the products if it exists\n//and add the new product to existing cart\n\nexport var getUpdatedProducts = function getUpdatedProducts(existingProductsInCart, product, qtyToBeAdded) {\n  var newQty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  //does product already exist in cart\n  var productExistsIndex = isProductInCart(existingProductsInCart, product.productId); //if product exists (index of that product is found in the array), update the product qty and total price\n\n  if (-1 < productExistsIndex) {\n    var updatedProducts = existingProductsInCart;\n    var updatedProduct = updatedProducts[productExistsIndex]; //if we have the new qty of the product available, set that else add tohe qtyTobeadded\n\n    updatedProduct.qty = newQty ? parseInt(newQty) : parseInt(updatedProduct.qty + qtyToBeAdded);\n    updatedProduct.totalPrice = parseFloat(updatedProduct.price * updatedProduct.qty).toFixed(2);\n    return updatedProducts;\n  } else {\n    //if it doesnt exist, it's a new product\n    var productPrice = getFloatval(product.price);\n    var newProduct = createNewProduct(product, productPrice, qtyToBeAdded);\n    existingProductsInCart.push(newProduct);\n    return existingProductsInCart;\n  }\n}; //return indes of the product if it exists\n\nexport var isProductInCart = function isProductInCart(existingProductsInCart, productId) {\n  console.log(\"hee hee\", existingProductsInCart, productId);\n\n  var returnItemThatExists = function returnItemThatExists(item, index) {\n    if (productId === item.productId) {\n      return item;\n    }\n  };\n\n  var newArray = existingProductsInCart.filter(returnItemThatExists);\n  return existingProductsInCart.indexOf(newArray[0]);\n};","map":{"version":3,"sources":["/Users/Eunice/WebDev/Fellowship/woo-less/function.js"],"names":["getFloatval","string","console","log","floatValue","match","parseFloat","toFixed","addFirstProduct","product","productPrice","price","newCart","products","totalProductsCount","totalProductsPrice","newProduct","createNewProduct","push","localStorage","setItem","JSON","stringify","qty","productId","image","name","totalPrice","updateCart","existingCart","qtyToBeAdded","newQty","updatedProducts","getUpdatedProducts","addPrice","total","item","reduce","updatedCart","parseInt","existingProductsInCart","productExistsIndex","isProductInCart","updatedProduct","returnItemThatExists","index","newArray","filter","indexOf"],"mappings":"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","sourcesContent":["export const getFloatval =(string)=>{\n    console.log(\"string\", string)\n\n    let floatValue = string.match( /[+-]?\\d+(\\.\\d+)?/g )[0];\n\treturn (null !== floatValue)? parseFloat( parseFloat( floatValue ).toFixed( 2 ) ) : '';\n}\n\nexport const addFirstProduct=(product)=>{\n    console.log('heey from inside the addproduct')\n    let productPrice = getFloatval(product.price)\n\n\n    //if no item in the cart, create an n empty array and pushe the item\n\n    let newCart ={\n        products:[],\n        totalProductsCount:1, \n        totalProductsPrice:productPrice\n    }\n\n    const newProduct = createNewProduct(product, productPrice, 1); //qty is 1 b/c its the first time we're creating it\nnewCart.products.push(newProduct);\nlocalStorage.setItem('woo-next-cart', JSON.stringify(newCart));\nreturn newCart\n}\n\n//CREATE A NEW PRODUCT OBJECT\n\n\nexport const createNewProduct =(product, productPrice, qty)=>{\n    return{\n        productId: product.productId,\n        image:product.image,\n        name:product.name,\n        price:productPrice,\n        qty: qty,\n        totalPrice: parseFloat((productPrice * qty).toFixed(2))\n    }\n}\n\nexport const updateCart= (existingCart, product, qtyToBeAdded, newQty=false)=>{\n    const updatedProducts = getUpdatedProducts(existingCart.products, product, qtyToBeAdded, newQty);\n    const addPrice = (total, item)=>{\n        total.totalPrice += item.totalPrice;\n        total.qty+= item.qty\n\n        return total\n    }\n\n    //loop thtrough the update produt array and add the totalPrice of each item to get the totalPrice.\n    let total = updatedProducts.reduce(addPrice, {totalPrice:0, qty:0})\n\n    //updated card\n    const updatedCart ={\n        products: updatedProducts,\n        totalProductsCount: parseInt(total.qty),\n        totalProductsPrice: parseFloat(total.totalPrice)\n\n    }\n    localStorage.setItem('woo-next-cart', JSON.stringify(updatedCart))\n    return updatedCart\n}\n\n//get updated products array\n//updated the products if it exists\n//and add the new product to existing cart\n\nexport const getUpdatedProducts =(existingProductsInCart, product, qtyToBeAdded, newQty=false)=>{\n    //does product already exist in cart\n    const productExistsIndex = isProductInCart(existingProductsInCart, product.productId)\n\n    //if product exists (index of that product is found in the array), update the product qty and total price\n\n    if(-1 <productExistsIndex){\n        let updatedProducts = existingProductsInCart;\n        let updatedProduct = updatedProducts[productExistsIndex];\n\n        //if we have the new qty of the product available, set that else add tohe qtyTobeadded\nupdatedProduct.qty =(newQty)?parseInt(newQty):parseInt(updatedProduct.qty+qtyToBeAdded);\nupdatedProduct.totalPrice = parseFloat(updatedProduct.price * updatedProduct.qty).toFixed(2)\n   return updatedProducts\n}else{\n    //if it doesnt exist, it's a new product\n    let productPrice = getFloatval(product.price);\n    const newProduct = createNewProduct(product, productPrice, qtyToBeAdded);\n    existingProductsInCart.push(newProduct)\n\n    return existingProductsInCart;\n}\n\n}\n\n//return indes of the product if it exists\n\nexport const isProductInCart=(existingProductsInCart, productId)=>{\n    console.log(\"hee hee\", existingProductsInCart, productId)\n    const returnItemThatExists = (item, index)=>{\n        if(productId === item.productId){\n            return item;\n        }\n\n    }\n    const newArray = existingProductsInCart.filter(returnItemThatExists);\n    return existingProductsInCart.indexOf(newArray[0]);\n\n}\n"]},"metadata":{},"sourceType":"module"}